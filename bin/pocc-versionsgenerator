#!/usr/bin/perl -w
## pocc-versionsgenerator.pl for pocc in /Users/pouchet
##
## Made by Louis-Noel Pouchet
## Contact: <louis-noel.pouchet@inria.fr>
##
## Started on  Wed Apr 15 18:50:36 2009 Louis-Noel Pouchet
## Last update Mon Mar 22 00:54:11 2010 Louis-Noel Pouchet
##
#
# pocc-versionsgenerator: this file is part of the PoCC project.
#
# PoCC, the Polyhedral Compiler Collection package
#
# Copyright (C) 2009,2010 Louis-Noel Pouchet
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# The complete GNU General Public Licence Notice can be found as the
# `COPYING.LESSER' file in the root directory.
#
# Author:
# Louis-Noel Pouchet <Louis-Noel.Pouchet@inria.fr>
#

use Switch;
use Term::ANSIColor;


sub print_versions
{
    my (%config) = @_;
    ## Print config table.
    my $i;
    my $flag;
    for $flag (keys %config) {
	for $field (keys %{$config{$flag}}) {
	    my @array = @{$config{$flag}{$field}};
	    for ($i = 0; $i <= $#array; $i++) {
		$value = $array[$i];
		print "$flag: $field -> $value\n";
	    }
	}
    }
}

sub read_versions_file
{
    my ($file) = @_;
    my %versions_data;
    open FILE, "$file" or die $!;
    my $opt = "";
    while (<FILE>) {
	if ($_ !~ /^#|^[\s\t]*\n/) {
	    $_ =~ s/(.*)\n/$1/g;
	    if ($_ =~ /^\[.*\]/) {
		$opt = $_;
		$opt =~ s/^\[(.*)\].*/$1/g;
		$versions_data{$opt}{"flag-name"}[0] = $opt;
	    }
	    else {
		my @entry = split(/:/, $_);
		$entry[0] =~ s/\s//g;
		my $data = $entry[1];
		my $i;
		for ($i = 2; $i <= $#entry; $i++) {
		    $data = $data . ":" . $entry[$i];
		}
		my @opts = split(/\|/, $data);
		@{$versions_data{$opt}{$entry[0]}} = @opts;
	    }
	}
    }

#    print_versions(%versions_data);

    return %versions_data;
}

sub dec2bin {
    my $str = unpack("B32", pack("N", shift));
#    $str =~ s/^0+(?=\d)//;   # otherwise you'll get leading zeros
    return $str;
}

sub generate_versions
{
    my ($version_file, $file) = @_;

    print "[PoCC-generator] Generate flag sequences from $version_file for file $file\n"; 
    ## Read default options.
    my %config = read_versions_file($version_file);

    ## Retrieve default option(s).
    my $default_opts;
    if (defined(%{$config{"default"}})) {
	$default_opts = $config{"default"}{"flags"}[0];
	## Remove it from the set of configurations.
	delete($config{"default"});
    }
    print "[PoCC-generator] Default options: $default_opts\n";

    ## FIXME: Deal with tile sizes.

    ## Loop on all options.
    my $i;
    my $k;
    my $l;
    ## Compute total number of on/off flags and create an array from that.
    my $count = 0;
    my @flag_array;
    my @flag_mutex;
    my @mutex_group;
    my $group_id = 1;
    for $flag (keys %config) {
	$base_flag = $config{$flag}{"flag-name"}[0];
	if (defined($config{$flag}{"values"})) {
	    my @array = @{$config{$flag}{"values"}};
 	    for ($i = 0; $i <= $#array; $i++) {
		$flag_mutex[$count] = $group_id;
		$flag_array[$count++] = $base_flag." ".$array[$i];
	    }
	}
	else {
	    $flag_mutex[$count] = 0;
	    $flag_array[$count++] = $base_flag;
	}
	if (defined($config{$flag}{"options"})) {
	    my @array = @{$config{$flag}{"options"}};
 	    for ($i = 0; $i <= $#array; $i++) {
		$flag_mutex[$count] = 0;
		$flag_array[$count++] = $base_flag." ".$array[$i];
	    }
	}
	$group_id++;
    }
    my $nb_opts = $#flag_array;

    ## Generate all combinations.
    my %final_flags;
    for ($k = 0; $k < 2 ** $nb_opts; $k++) {
	my $val = dec2bin($k);
	my $opt_str = $default_opts;
	for ($l = 0; $l < 32; $l++) {
	    $mutex_group[$l] = 0;
	}
	for ($l = 0; $l < 32; $l++) {
	    if (substr($val,$l, 1) eq "1") {
		if ($flag_mutex[31 - $l] != 0) {
		    if ($mutex_group[$flag_mutex[31 - $l]] == 0) {
			$opt_str = $opt_str . " " . $flag_array[31 - $l];
			$mutex_group[$flag_mutex[31 - $l]] = 1;
		    }
		}
		else {
		    $opt_str = $opt_str . " " . $flag_array[31 - $l];
		}
	    }
	}
	$final_flags{$opt_str} = 1;
    }
    my $nb_combinations = scalar keys %final_flags;
    print "[PoCC-generator] Total (optimistic) number of flags sequences: $nb_combinations\n";

    ## Call PoCC for each flag sequence
    $output_dir = $file;
    $output_dir =~ s/\.c$//g;
    $filename_prefix = $output_dir;
    $output_dir = $output_dir . "-pocc-flags";
    system("mkdir -p $output_dir");
    local $| = 1;
    my $version_ok = 0;
    for $flag_seq (keys %final_flags) {
	my $out_filename = $flag_seq;
	$out_filename =~ s/\s/_/g;
	$out_filename =~ s/--//g;
	$out_filename =~ s/__/_/g;
	$out_filename = $filename_prefix . $out_filename;
	my $ret = `pocc $flag_seq $file -o $output_dir/$out_filename.c 2>/dev/null`;
	print ".";
	if ($? != 0) {
	    print "Command failed\n";
	    system ("rm -f $output_dir/$out_filename.c");
	}
	else {
	    $version_ok++;
	}
    }
    print "\n";
    print "[PoCC-generator] Total number of versions created: $version_ok\n";
}


